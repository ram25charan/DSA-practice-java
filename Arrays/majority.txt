problem statement:
Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times.
You may assume that the majority element always exists in the array.
Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
 
Constraints:
n == nums.length
1 <= n <= 5 * 104
-109 <= nums[i] <= 109
The input is generated such that a majority element will exist in the array.

code:
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int candidate = -1;
        for(int i=0;i<nums.length;i++){
            if(count==0){
                candidate = nums[i];
                count = 1;
            }else{
                if(nums[i]==candidate){
                    count++;
                }else{
                    count--;
                }
            }
        }
        return candidate; 
    }
}
Intution: 
When the elements are the same as the candidate element, 
votes are incremented whereas when some other element is found (not equal to the candidate element),
we decreased the count. This actually means that we are decreasing the priority of winning 
ability of the selected candidate, since we know that if the candidate is in majority it occurs more than N/2 times
and the remaining elements are less than N/2. We keep decreasing the votes since we found some different element(s) 
than the candidate element. When votes become 0, this actually means that there are the equal  number of votes for different 
elements, which should not be the case for the element to be the majority element. 
So the candidate element cannot be the majority and hence we choose the present element as the candidate
and continue the same till all the elements get finished. The final candidate would be our majority element. 
We check using the 2nd traversal to see whether its count is greater than N/2. If it is true,
we consider it as the majority element.

Time Complexity: O(n) 
Space Complexity: O(1)
 
